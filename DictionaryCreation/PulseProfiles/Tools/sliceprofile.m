function [varargout]=sliceprofile(rf,grad,dt,T1,T2,pos,varargin)
% function Mz=sliceprofile(rf,grad,dt,T1,T2,pos[,df,M_in])
% function Mz=sliceprofile(rf,grad,dt,T1,T2,pos,df,B1)
% function Mz=sliceprofile(rf,grad,dt,T1,T2,pos,df,B1,M_in)
% function [Mx,My,Mz]=sliceprofile(...)
%
% Determine spatial profile of the magnetization vector generated by an
% arbitrary complex RF pulse in presence of a gradient pulse form, taking
% into account relaxation and off-resonance. By specifying a zero-amplitude
% RF vector, this can also be used to calculate the effect of free
% precession, relaxation and gradients in absence of RF.
%
% Input parameters:
%      rf:           vector of complex RF pulse samples. The magnitude
%                    should be scaled to indicate B1 field strength in
%                    Gauss.
%      grad:         vector of real gradient pulse samples, sampled at the
%                    same timepoints as the RF waveform. Amplitude in units
%                    of Gauss/cm. Can be a scalar in which case it
%                    indicates a constant gradient.
%      dt:           scalar indicating the duration of the pulse sampling
%                    intervals in seconds (uniform sampling), or vector of
%                    the size of 'rf' indicating the duration of each
%                    sample period, in seconds. Must be strictly positive.
%      T1:           spin-lattice relaxation time constant in seconds
%      T2:           spin-spin relaxation time constant in seconds
%      pos:          positions at which the spatial profile is to be
%                    evaluated, in mm
%      df:           frequency offset between the resonance frequency of
%                    the isochromats to consider and the RF carrier in Hz.
%                    Default is df=0.
%      B1:           vector (1xnumber of spatial samples) with relative B1
%                    field strength profile for positions in 'pos'. The
%                    actual peak B1 in Gauss at each position is
%                    max(abs(rf))*B1. B1 has to be real for now. Complex B1
%                    simulating position-dependent phase shift of the
%                    transmitted RF signal should work with a small code
%                    change.
%      M_in:         input magnetization profile (size 3xnumber of
%                    spatial samples in profile). Use [Mx';My';Mz'] to
%                    continue simulation from the result of a previous
%                    call. Default is the fully relaxed state.
%
% Output parameters:
%      [Mx,My,]Mz    vectors of size Nx1 containing the x-, y- and z-
%                    components of the magnetization vector after the RF
%                    pulse, N being the number of spatial samples (number
%                    of elements in POS). In case of a single output
%                    argument, only the z-component is returned. 
%
% based on code from http://www-mrsrl.stanford.edu/~brian/bloch/
%
% extensive modifications by Jan Warnking, Grenoble Institut des Neurosciences,
% Centre de Recherche INSERM U836 - UJF-CEA-CHU, Grenoble, France 
%


gamma = 4258;                      % gyoromagnetic ratio for protons, Hz/Gauss

n_timepoints = numel(rf);          % number of temporal points in the waveforms
rf = reshape(rf,[n_timepoints 1]);

if numel(grad)==1,                 % case of constant gradient
    grad = repmat(grad,[n_timepoints 1]);
else
    grad = reshape(grad,[n_timepoints 1]); % if size of grad is wrong, this will fail
end;

n_positions = numel(pos);          % number of spatial positions in the profile
pos = reshape(pos,[1 n_positions]);

if nargin < 7,
    df = 0;
else
    df = varargin{1};
end;
if numel(dt)==1,
    dt = repmat(dt,[n_timepoints 1]);
else
    dt = reshape(dt,[n_timepoints 1]); % if size of dt is wrong, this will fail
end;

variable_b1 = false;               % by default assume no B1-profile is given

% M is the magnetization (x,y,z) for each position (1..length(pos))
if nargin < 8,
    O = zeros(1,n_positions);
    l = ones (1,n_positions);
    M = [O;O;l];             % magnetization before RF pulse: all along z, fully relaxed
end;

if nargin == 8,                    % check whether 8th argument is M_in or B1
    if size(varargin{2},2) ~= n_positions, % check the length is ok
        error('The 8th input argument must be of the same length as ''pos''.');
    end;
    switch size(varargin{2},1);    % width of the matrix
        case 1,
            variable_b1 = true;
            B1 = varargin{2};      % this is a vector of B1s
            O = zeros(1,n_positions);
            l = ones (1,n_positions);
            M = [O;O;l];           % magnetization before RF pulse: all along z, fully relaxed

        case 3,                    % this is 3*n_positions
            M = varargin{2};       % start with given magnetization (from previous simulations)
            
        otherwise,
            error('The 8th input argument must be a vector of B1s or a matrix of N 3-element magnetization vectors.');
    end;
end;

if nargin == 9,
    variable_b1 = true;
    if size(varargin{2},2) ~= n_positions, % chech the length is ok
        error('The 8th input argument must be of the same length as ''pos''.');
    end;
    B1 = varargin{2};      % this is a vector of B1s
    if size(varargin{3},2) ~= n_positions, % chech the length is ok
        error('The 9th input argument must be of the same length as ''pos''.');
    end;
    M = varargin{3};       % start with given magnetization (from previous simulations)
end;

rfrot = 2*pi*gamma*rf.*dt;         % Rotation in radians for each discrete RF sample

% effect of the slice-select gradient:
grad_mom0 = grad.*dt/2;            % 0-th order gradient moment for half of each sample (in s*Gauss/cm)
grad_mom0_initial  = grad_mom0(1); % half of the first gradient sample, applied before the loop
% in the time-loop, combine gradient moment of half of step k and half of
% step k+1 and apply after the RF. The last sample is half of the last step.
grad_mom0(1:end-1) = grad_mom0(1:end-1)+grad_mom0(2:end);

% the dephasing due to gradients will depend on position:
pos = 2*pi*gamma*pos/10;           % convert to (rad/s)/(Gauss/cm)

% the effect of free precession:
% free precession commutes with the gradient dephasing, and therefore we
% can combine free precession at the end of one sample with free precession
% at the beginning of the next sample, just as for the gradients.
% Interpolate the sampling timepoints accordingly:
dt_initial  = dt(1)/2;
dt(1:end-1) = (dt(1:end-1)+dt(2:end))/2;
dt(end)     = dt(end)/2;
% calculate matrix for relaxation processes during free precession between
% RF samples
[Ai,Bi] = freeprecess(dt_initial,T1,T2,df); % first half timestep
[A,B] = freeprecess(dt,T1,T2,df); % calculate all other timesteps in parallel
% B only has a z-component:
Bz = B(3,:,:);

if ~variable_b1, % RF rotations are the same for all positions
    T = throt3(rfrot);                 % calculate RF rotations, stack time intervals in the 3rd dimension

    % Combine matrix for RF and free precession outside of the time-loop
    % for faster calculation.
    %
    % We need to calculate: AT = A*T;
    % But we can't use matrix multiply since A and T potentially are 3x3xN.
    % We could loop over N, but that's slooooow. Use much shorter loops
    % over the 9 elements of the 3x3 matrix. To use Matlab's
    % element-by-element multiplication and internal fast sum, we need to
    % transpose A, so that the rows of A become 'parallel' to the columns
    % of T:
    A2 = permute(A,[2 1 3]);           % 'transpose' only works for 2D. Use 'permute'.
    AT = zeros([3,3,n_timepoints]);    % prepare space
    for l = 1:3,                       % short loop over matrix indices
        for k = 1:3,
            AT(k,l,:) = sum(A2(:,k,:).*T(:,l,:));
        end;
    end;
else
    AT = A; % in this case this is just free precession. We'll call it AT anyways.
end;

% now that we have prepared everything, do the calculations
% apply initial half gradient sample
phi = pos*grad_mom0_initial; c = cos(phi); s = sin(phi); % gradient rotates by phi
M = [c.*M(1,:)-s.*M(2,:);s.*M(1,:)+c.*M(2,:);M(3,:)]; % apply the phase shift due to gradient
M = [Ai(1,:)*M;Ai(2,:)*M;Ai(3,:)*M+Bi(3)]; % initial free precession

if variable_b1,
    % Assume B1 is real and split RF into power and phase components
    rfrot_abs = abs(rfrot);
    rfrot_angle = angle(rfrot);
    B1 = abs(B1);
end;
    
% now loop, apply RF, free precession and gradient iteratively
for k = 1:n_timepoints             % loop over gradient and RF samples, process all positions in parallel
    % We used to simulate in the following order:
    %    [gradient_k/2,relaxation_k/2],RF,[relaxation_k/2,gradient_k/2].
    % this used to be for each k in the iteration (in pseudocode,
    % dimensions of variables don't match):
    %    Z = zrot(pos*grad_mom0(k));
    %    M = Z*M;                     % apply the phase shift due to gradient
    %    M = A_k*M + B_k;             % next some free precession (and relaxation)
    %    M = T_k*M;                   % the RF pulse
    %    M = A_k*M + B_k;             % more free precession
    %    M = Z*M;                     % some more phase shift due to gradient
    %
    % Gradients and relaxation commute. This means, we can simplify:
    %    [RF,(gradient_k + gradient_k+1)/2,(relaxation_k + relaxation_k+1)/2]
    % which reads as:
    %    M = A_k'*T_k*M; 
    %    M = Z'*M + B_k';
    % where the primes indicate transformations corresponding one half of
    % the current sample and one half of the next (except for the last
    % iteration).
    
    if variable_b1,
        % for variable B1, the RF rotations are not the same for each spatial
        % location and we need to apply them separately
        % calculate x, y and z rows of the RF rotations for this timestep
        [Tx,Ty,Tz] = throt2(B1*rfrot_abs(k),rfrot_angle(k)); % Matrices for all positions (depending on B1)
        M = [sum(Tx.*M);sum(Ty.*M);sum(Tz.*M)]; % apply
    end;
        
    % apply free precession (and RF if B1 is constant)
    M = AT(:,:,k)*M;
    
    % longitudinal recuperation and phase shift due to gradient
    phi = pos*grad_mom0(k); c = cos(phi); s = sin(phi); % gradient rotates by phi
    M = [c.*M(1,:)-s.*M(2,:);s.*M(1,:)+c.*M(2,:);M(3,:)+Bz(k)];
end;

nout = max(nargout,1);             % use at least one output argument
if nout > 1,                       % return full matrix
    varargout{1} = M(1,:)';
    varargout{2} = M(2,:)';
    varargout{3} = M(3,:)';
else                               % return only longitudinal component
    varargout{1} = M(3,:)';
end;