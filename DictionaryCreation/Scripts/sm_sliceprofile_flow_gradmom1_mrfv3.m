function [Signal]=sm_sliceprofile_flow_gradmom1(Sequence,PulseProfile, Parameters, T1,T2,df,B1,v,pos,M)      % rfrot,grad_pre0,grad_pre1,grad_post0,grad_post1,TE,TR,T1,T2,pos,min_pos_init,max_pos_init,df,v,M,B1)
% Renvoie les aimantations a moyenne de l'aimantation des 10 derni�res it�rations
% function Mz =  sm_sliceprofile_flow_gradmom1(rfrot,grad_pre0,grad_pre1,grad_post0,grad_post1,TE,TR,T1,T2,pos,min_pos_init,max_pos_init,df,v,M,B1)

% Determine spatial profile of the magnetization vector generated by an
% arbitrary complex RF pulse in presence of a gradient pulse form, taking
% into account relaxation and off-resonance. By specifying a zero-amplitude
% RF vector, this can also be used to calculate the effect of free
% precession, relaxation and gradients in absence of RF.
%
% Input parameters:
%      rf:           vector of complex RF pulse samples. The magnitude
%                    should be scaled to indicate B1 field strength in
%                    Gauss.
%      grad:         vector of real gradient pulse samples, sampled at the
%                    same timepoints as the RF waveform. Amplitude in units
%                    of Gauss/cm. Can be a scalar in which case it
%                    indicates a constant gradient.
%      dt:           scalar indicating the duration of the pulse sampling
%                    intervals in seconds (uniform sampling), or vector of
%                    the size of 'rf' indicating the duration of each
%                    sample period, in seconds. Must be strictly positive.
%      T1:           spin-lattice relaxation time constant in seconds
%      T2:           spin-spin relaxation time constant in seconds
%      pos:          positions at which the spatial profile is to be
%                    evaluated, in mm
%      df:           frequency offset between the resonance frequency of
%                    the isochromats to consider and the RF carrier in Hz.
%                    Default is df=0.
%      v:            vector of flow velocities in mm/s MUST BE POSITIVE --------------------- NON PLUS MAINTENANT NORMALEMENT
%      B1:           vector (1xnumber of spatial samples) with relative B1
%                    field strength profile for positions in 'pos'. The
%                    actual peak B1 in Gauss at each position is
%                    max(abs(rf))*B1. B1 has to be real for now. Complex B1
%                    simulating position-dependent phase shift of the
%                    transmitted RF signal should work with a small code
%                    change.
%      M_in:         input magnetization profile (size 3xnumber of
%                    spatial samples in profile). Use [Mx';My';Mz'] to
%                    continue simulation from the result of a previous
%                    call. Default is the fully relaxed state.
%
% Output parameters:
%      [Mx,My,]Mz    vectors of size Nx1 containing the x-, y- and z-
%                    components of the magnetization vector after the RF
%                    pulse, N being the number of spatial samples (number
%                    of elements in POS). In case of a single output
%                    argument, only the z-component is returned.
%
% based on code from http://www-mrsrl.stanford.edu/~brian/bloch/
%
% extensive modifications by Jan Warnking, Grenoble Institut des Neurosciences,
% Centre de Recherche INSERM U836 - UJF-CEA-CHU, Grenoble, France
%


% LISTE DE MATRICES DE ROTATION
indicesRot=zeros([1 length(Sequence.FA)]);
for kFA=1:length(Sequence.FA)
    indicesRot_temp=find(abs(PulseProfile.FAlistdeg(:)-Sequence.FA(kFA)*B1*180/pi)==min(abs(PulseProfile.FAlistdeg(:)-Sequence.FA(kFA)*B1*180/pi)));
    indicesRot(kFA)=indicesRot_temp(1);
end
%PulseProfile.Rot=squeeze(PulseProfile.Rot(:,:,:,indicesRot(:)));
PulseProfile.Rot=PulseProfile.Rot(:,:,:,indicesRot(:));
% When 1 pos only, the squeeze suppreses the third dimension
clear indicesRot kFA indicesRot_temp



gamma = 2*pi*42.5764e6; % rad/(s.T)

% the dephasing due to gradients will depend on position
dpos = v*Parameters.TR(:)'; % millimeters

% the effect of free precession:
% calculate matrix for relaxation processes during gradient pulses
[Apre,Bpre]   = freeprecess(Parameters.TE,T1,T2,df); % first part of TR, until acquisition
[Apost,Bpost] = freeprecess(Parameters.TR-Parameters.TE,T1,T2,df); % second part of TR

% B only has a z-component:
Bzpre = Bpre(3,:,:);
Bzpost = Bpost(3,:,:);


% !    % Assume B1 is real and split RF into power and phase components
% !    rfrot_abs = abs(rfrot);
% !    rfrot_angle = angle(rfrot);
% !    B1 = abs(B1); % ?? why ignore that a profile may have negative values ?

this_pos = pos;
pos_res = median(diff(pos));
% sim_width = Parameters.max_pos_init - Parameters.min_pos_init; % This is not slice thickness, but width of the simulated slab, which is larger.

% spin dephasing due to first order gradient moments
phi_pre1  = gamma*v*Parameters.Gpre1;%grad_pre1;
phi_post1 = gamma*v*Parameters.Gpost1;%grad_post1;

nTR = numel(Parameters.TE);%numel(rfrot);
Signal = zeros(1,nTR);
% now loop, apply RF, free precession and gradient iteratively
for k = 1:nTR
    % loop over TRs. In each TR we consider a sequence of:
    %   - RF (instantaneous),
    %   - gradients/relaxation (during TE, including second half of slice select grad),
    %   - acquisition,
    %   - gradients/relaxation (during TR-TE, including first half of slice select grad),
    %   - motion of spins      (forget about spins that left the slice)
    
    % In terms of operations on the magnetization this becomes:
    %    Z = zrot(pos*grad_mom0(k) + v*grad_mom1(k));
    %    M = T*M;             % the RF pulse
    %    M = Apre*M + Bpre;   % free precession pre-acquisition
    %    M = Zpre*M;          % phase shift due to zeroth and first gradient moment
    %                         % store signal here
    %    M = Apost*M + Bpost; % free precession post-acquisition
    %    M = Zpost*M;         % phase shift due to zeroth and first gradient moment
    %    pos = pos + dpos;    % update spin positions due to flow
    
    % for variable B1, the RF rotations are not the same for each spatial
    % location and we need to apply them separately
    % calculate x, y and z rows of the RF rotations for this TR
    
    % effect of the RF Pulse
    if (Sequence.FA(k)*B1)~=0
        M=[sum(squeeze(PulseProfile.Rot(1,:,:,k)).*M,1);sum(squeeze(PulseProfile.Rot(2,:,:,k)).*M,1);sum(squeeze(PulseProfile.Rot(3,:,:,k)).*M,1)]; %A VERIFIER !!!!! ------------
    end
    
    % apply free precession
    M = Apre(:,:,k)*M;
    
    % longitudinal recuperation and phase shift due to gradient
    phi = gamma*this_pos*Parameters.Gpre0(k) + phi_pre1(k);
    c = cos(phi); s = sin(phi); % gradient rotates by phi
    M = [c.*M(1,:)-s.*M(2,:);s.*M(1,:)+c.*M(2,:);M(3,:)+Bzpre(k)];
    
    % average over all spins in the slice to get total signal
    meanM = mean(M,2); % mean magnetization
    Signal(k) = meanM(1) + 1i*meanM(2); % complex signal from transverse magnetization
    
    % plot magnetization
    %     hold off
    %     plot(M(1,:));
    %     hold on
    %     plot(M(2,:),'r');
    %     plot(M(3,:),'k');
    %     set(gca,'YLim',[-1 1])
    %     title(sprintf('FA: %d, ph: %d TR: %d, TE: %d',(180/pi)*rfrot_abs(k),(180/pi)*rfrot_angle(k),1000*TR(k),1000*TE(k)))
    %     pause;
    %     ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    % apply free precession
    M = Apost(:,:,k)*M;
    
    % longitudinal recuperation and phase shift due to gradient
    phi = gamma*this_pos*Parameters.Gpost0(k) + phi_post1(k);
    c = cos(phi); s = sin(phi); % gradient rotates by phi
    M = [c.*M(1,:)-s.*M(2,:);s.*M(1,:)+c.*M(2,:);M(3,:)+Bzpost(k)];
    
    this_pos = this_pos+dpos(k);
    
    out_of_slice = (this_pos > Parameters.max_pos_init) | (this_pos < Parameters.min_pos_init);
    if any(out_of_slice)
        oos = find(out_of_slice); % we use this multiple times, make indexing a little faster
        n_shift = numel(oos);
        if dpos>0
            M = [[zeros(2,n_shift);ones(1,n_shift)] M(:,1:end-n_shift)];
            this_pos = this_pos - n_shift*pos_res;
        else
            M = [M(:,n_shift+1:end) [zeros(2,n_shift);ones(1,n_shift)]];
            this_pos = this_pos + n_shift*pos_res;
        end
        
    end
    
end


% Si plusieurs blocs : [Signal,M,this_pos] en sortie
end